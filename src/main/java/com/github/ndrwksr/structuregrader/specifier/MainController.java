package com.github.ndrwksr.structuregrader.specifier;

import com.github.ndrwksr.structuregrader.core.*;
import com.github.ndrwksr.structuregrader.core.specification.clazz.ClassMapSuite;
import com.github.ndrwksr.structuregrader.core.visitor.Spec;
import com.github.ndrwksr.structuregrader.core.wrapper.*;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.layout.AnchorPane;
import javafx.stage.FileChooser;
import javafx.stage.Window;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ResourceBundle;

public class MainController implements Initializable {
	@FXML
	@Setter
	public AnchorPane root;
	@FXML
	public TreeView<String> projectTree;
	@FXML
	public TreeView<String> specificationTree;
	@FXML
	public TextArea descriptionTextArea;
	@FXML
	public TextField pkgToScanField;
	@FXML
	public Label loadedJarLabel;
	@FXML
	public Button scanPackageButton;
	@FXML
	public TextArea logTextArea;
	@FXML
	public Button removeSpecButton;
	@FXML
	public Button clearPackageButton;
	@FXML
	public Button specifyPackageButton;
	@FXML
	public Button exportButton;
	@FXML
	public Button clearSpecificationStackButton;

	/**
	 * Property for the URLClassLoader which loads in a jar for analysis.
	 */
	@NonNull
	private SimpleObjectProperty<URLClassLoader> urlClassLoaderSop = new SimpleObjectProperty<>(null);

	/**
	 * Property for the name of the package within the jar to scan.
	 */
	@NonNull
	private SimpleStringProperty pkgToScanSsp = new SimpleStringProperty(null);

	/**
	 * Property for the ClassMap generated by scanning the loaded jar.
	 */
	@NonNull
	private SimpleObjectProperty<ClassMap> classMapSop = new SimpleObjectProperty<>(null);
	/**
	 * Property for the ClassMapSuite generated by specifying the ClassMap.
	 */
	@NonNull
	private SimpleObjectProperty<ClassMapSuite> classMapSuiteSop = new SimpleObjectProperty<>(null);

	@Override
	public void initialize(final URL location, final ResourceBundle resources) {
		// Disable these controls when no jar has been specified
		pkgToScanField.disableProperty().bind(Bindings.isNull(urlClassLoaderSop));
		scanPackageButton.disableProperty().bind(Bindings.isNull(urlClassLoaderSop));

		final BooleanBinding classMapSopIsNullBind = Bindings.isNull(classMapSop);
		final BooleanBinding specificationTreeIsEmptyBind = Bindings.isNull(specificationTree.rootProperty());
		// Disable the Clear Package when no package has been scanned yet
		clearPackageButton.disableProperty().bind(classMapSopIsNullBind);
		// Disable the Specify Package button when no package has been scanned yet or we've already specified a package
		specifyPackageButton.disableProperty().bind(classMapSopIsNullBind.or(specificationTreeIsEmptyBind.not()));

		// Disable the Remove Specification button when no specification is selected in the specification tree view
		removeSpecButton.disableProperty().bind(specificationTree.getSelectionModel().selectedItemProperty().isNull());
		// Disable the Clear Specification Stack button when there is no loaded specification tree
		clearSpecificationStackButton.disableProperty().bind(specificationTreeIsEmptyBind);
		// Disable the Export button when there is no loaded specification tree
		exportButton.disableProperty().bind(specificationTreeIsEmptyBind);

		// When a new jar is chosen, clear the previously-scanned package's ClassMap
		urlClassLoaderSop.addListener((observable, oldValue, newValue) -> classMapSop.set(null));


		classMapSop.addListener(($1, $2, newValue) -> {
			if (newValue != null) {
				// When a package is analyzed, create the tree for it and display it in projectTree
				final TreeItem<String> root = new TreeItem<>(newValue.getName());
				newValue.getItems().forEach((name, clazz) -> root.getChildren().add(treeItemFromClass(clazz)));
				projectTree.setRoot(root);
			} else {
				// When an analyzed package is cleared, clear projectTree too
				projectTree.setRoot(null);
			}
		});

		// Set description when an item in the specification tree is selected.
		specificationTree.getSelectionModel().selectedItemProperty().addListener(($1, $2, newValue) -> {
			// Weak OOP, but gets the job done. Could be addressed by making a custom TreeView.
			// TODO: Refactor so that all TreeItems descend from a superclass which has getSpecDescription()
			final String description = (newValue instanceof SpecTreeItem)
					? ((SpecTreeItem)(newValue)).getSpec().getSpecDescription()
					: "No description available.";

			descriptionTextArea.setText(description);
		});

		// When a package to scan has been selected, analyze it and set classMapSop to the new ClassMap
		pkgToScanSsp.addListener(($1, $2, newValue) -> {
			assert urlClassLoaderSop.get() != null;

			try {
				classMapSop.set(ClassMap.buildFromPackage(
						urlClassLoaderSop.get(),
						pkgToScanField.getText()
				));
			} catch (IOException e) {
				e.printStackTrace();
				logTextArea.appendText(e.getMessage() + '\n');
			}
		});


		classMapSuiteSop.addListener(($1, $2, newValue) -> {
			if (newValue != null) {
				// When a ClassMap has been specified and we have a new ClassMapSuite, display it in specificationTree
				final TreeItem<String> rootItem = treeItemFromSpec(
						newValue,
						"root",
						null,
						() -> logTextArea.appendText("Cannot delete root specification from specification stack!\n")
				);
				specificationTree.setRoot(rootItem);
			} else {
				// When the specification stack is cleared, clear specificationTree too
				specificationTree.setRoot(null);
			}
		});
	}

	/**
	 * Loads an existing specification stack back in for further editing.
	 */
	@FXML
	public void openSpecStackWasClicked() {
		FileChooser fileChooser = new FileChooser();
		fileChooser.setSelectedExtensionFilter(
				new FileChooser.ExtensionFilter(".spec files", ".spec")
		);
		final File file = fileChooser.showOpenDialog(getWindow());
		if (file != null) {
			try {
				final String specJson = Files.readString(Path.of(file.getAbsolutePath()));
				final ClassMapSuite classMapSuite = ClassMapSuite.JsonHelper.fromJson(
						specJson,
						$ -> {
						} // NOOP noncomplianceConsumer
				);
				classMapSuiteSop.set(classMapSuite);
			} catch (IOException e) {
				logTextArea.appendText(e.getLocalizedMessage() + '\n');
			}
		}
	}

	/**
	 * Creates a new URLClassLoader to analyze the specified jar.
	 */
	@FXML
	public void analyzeProjectWasClicked() {
		FileChooser fileChooser = new FileChooser();
		fileChooser.setSelectedExtensionFilter(
				new FileChooser.ExtensionFilter(".jar files", ".jar")
		);

		final File jar = fileChooser.showOpenDialog(getWindow());

		try {
			final URL jarUrl = new URL("file:" + jar.getAbsolutePath());
			final URL[] urls = {jarUrl};

			urlClassLoaderSop.set(URLClassLoader.newInstance(urls));
			loadedJarLabel.setText(jarUrl.getFile());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Sets the property for the package to scan. Binding will take it from here.
	 */
	@FXML
	public void scanPackageWasClicked() {
		pkgToScanSsp.set(pkgToScanField.getText());
	}

	/**
	 * Removes the selected item from specificationTree.
	 */
	@FXML
	public void removeSpecWasClicked() {
		// This isn't a rigorous cast, but we have complete control over the contents of the tree and only ever insert
		// custom TreeItems which implement Removable.
		// We could have subclassed TreeView, but it would have been a lot of code just to avoid this one line.
		((Removable) specificationTree.getSelectionModel().getSelectedItem()).remove();
	}

	/**
	 * Clears the ClassMap property. Binding will take it from here.
	 */
	@FXML
	public void clearPackageWasClicked() {
		classMapSop.set(null);
	}

	/**
	 * Specifies the selected package, and sets the ClassMapSuite property. Binding will cascade necessary updates.
	 */
	@FXML
	public void specifyPackageWasClicked() {
		final ClassMapSuite classMapSuite = ClassMapSuite.ClassMapSuiteFactory.getDefaultInst().buildFromCollection(
				classMapSop.get(),
				classMapSop.get().getName(),
				$ -> {
				} // NOOP noncomplianceConsumer
		);
		classMapSuiteSop.set(classMapSuite);
	}

	/**
	 * Exports the current state of classMapSuiteSop to JSON for deployment or just to save for later editing.
	 */
	@FXML
	public void exportWasClicked() {
		try {
			final String json = ClassMapSuite.JsonHelper.toJson(classMapSuiteSop.get());
			FileChooser fileChooser = new FileChooser();
			fileChooser.setTitle("Save Specification Stack");
			final File file = fileChooser.showSaveDialog(getWindow());
			if (file != null) {
				Files.writeString(Path.of(file.getAbsolutePath()), json);
			}
		} catch (IOException e) {
			logTextArea.appendText(e.getMessage() + '\n');
		}
	}

	/**
	 * Clears the specification stack property. Binding will take it from here.
	 */
	@FXML
	public void clearSpecificationStackWasClicked() {
		classMapSuiteSop.set(null);
	}

	/**
	 * Generates a tree item for projectTree from a class. Recursive.
	 *
	 * @param clazz The class from which a TreeItem will be created.
	 * @return the newly-generated TreeItem representing the provided class.
	 */
	private TreeItem<String> treeItemFromClass(@NonNull final ClassWrapper clazz) {
		final TreeItem<String> classItem = new TreeItem<>(clazz.getName());

		// Make an item for inner classes. Recursive.
		final NamedMap<ClassWrapper> declaredClasses = clazz.getDeclaredClasses();
		if (!declaredClasses.getItems().isEmpty()) {
			final TreeItem<String> declaredClassesRoot = new TreeItem<>("Declared Classes");
			declaredClasses.getItems().forEach(
					(name, innerClass) -> declaredClassesRoot.getChildren().add(treeItemFromClass(innerClass))
			);
			classItem.getChildren().add(declaredClassesRoot);
		}

		// Make an item for annotations
		final NamedMap<AnnotationWrapper> annotations = clazz.getAnnotationWrappers();
		if (!annotations.getItems().isEmpty()) {
			final TreeItem<String> annotationsRoot = new TreeItem<>("Runtime-Retained Annotations");
			annotations.getItems().forEach(
					(name, annotation) -> annotationsRoot.getChildren().add(new TreeItem<>(annotation.getName()))
			);
			classItem.getChildren().add(annotationsRoot);
		}

		// Make an item for constructors
		final NamedSet<ConstructorWrapper> constructors = clazz.getConstructors();
		if (!constructors.getItems().isEmpty()) {
			final TreeItem<String> constructorsRoot = new TreeItem<>("Constructors");
			constructors.getItems().forEach(
					constructor -> constructorsRoot.getChildren().add(new TreeItem<>(constructor.getSignature()))
			);
			classItem.getChildren().add(constructorsRoot);
		}

		// Make an item for fields
		final NamedMap<FieldWrapper> fields = clazz.getFields();
		if (!fields.getItems().isEmpty()) {
			final TreeItem<String> fieldsRoot = new TreeItem<>("Fields");
			fields.getItems().forEach(
					(name, field) -> fieldsRoot.getChildren().add(new TreeItem<>(field.getName()))
			);
			classItem.getChildren().add(fieldsRoot);
		}

		// Make an item for methods
		final NamedMap<MethodWrapper> methods = clazz.getMethods();
		if (!methods.getItems().isEmpty()) {
			final TreeItem<String> methodsRoot = new TreeItem<>("Methods");
			methods.getItems().forEach(
					(name, method) -> {
						final Type genericType = method.getGenericType();
						final Type type = method.getType();

						final String itemStr = (
								genericType != null ?
										genericType.getTypeName() :
										type.getTypeName()
						) + ' ' + method.getName();
						methodsRoot.getChildren().add(new TreeItem<>(itemStr));
					}
			);
			classItem.getChildren().add(methodsRoot);
		}

		// Make an item for interfaces
		final NamedSet<ClassWrapper> interfaces = clazz.getInterfaces();
		if (!interfaces.getItems().isEmpty()) {
			final TreeItem<String> interfacesRoot = new TreeItem<>("Interfaces");
			interfaces.getItems().forEach(
					interface_ -> interfacesRoot.getChildren().add(new TreeItem<>(interface_.getName()))
			);
			classItem.getChildren().add(interfacesRoot);
		}

		return classItem;
	}

	/**
	 * Generates a TreeItem for a specification. Recursive.
	 *
	 * @param rootSpec                   The specification from which to create a TreeItem.
	 * @param prefix                     Used to include the key in a MapSpec in the generated TreeItem.
	 *                                   For example, in the map for a class's fields, {a: VariableSuite, b: VariableSuite},
	 *                                   this method would be called on both variable suites with 'a' and 'b' as the prefix respectively.
	 * @param parentItem                 The parent tree item for this tree item. Used so that our custom tree items can keep track of
	 *                                   to whom they belong for the purpose of being able to remove themselves from the tree.
	 * @param removeFromParentCollection A Runnable which removes rootSpec from its parent specification. Used so that our
	 *                                   custom tree items can remove themselves from the ClassMapSuite.
	 * @return the generated TreeItem for the provided specification.
	 */
	private TreeItem<String> treeItemFromSpec(
			@NonNull final Spec rootSpec,
			final String prefix,
			final TreeItem<String> parentItem,
			final Runnable removeFromParentCollection
	) {
		final String rootTitle = rootSpec.specTypeName() + ": "
				+ (prefix != null ? prefix + " -> " : "") + rootSpec.getParentName();
		final SpecTreeItem rootItem = new SpecTreeItem(
				rootTitle,
				rootSpec
		);
		rootItem.setRemove(() -> {
			if (removeFromParentCollection != null) {
				removeFromParentCollection.run();
			}

			if (parentItem != null) {
				parentItem.getChildren().remove(rootItem);
			}

			if (removeFromParentCollection != null || parentItem != null) {
				specificationTree.refresh();
			}
		});

		// It's very weak OO to have these casts which can be reasonably expected to fail.
		// This was done for time savings and no other reason. I'm sure a better way to do this exists, I didn't have time
		// to look for it.
		try {
			final NamedSpecSet<? extends Spec> specSet = HasChildSet.class.cast(rootSpec).getChildSet();
			final SetTreeItem setRootItem = new SetTreeItem("Specification Set: " + specSet.getName(), specSet);
			setRootItem.setRemove(() -> {
				specSet.clear();
				rootItem.getChildren().remove(setRootItem);
				specificationTree.refresh();
			});
			specSet.forEach(spec -> setRootItem.getChildren().add(treeItemFromSpec(spec, null, setRootItem, () -> specSet.remove(spec))));
			rootItem.getChildren().add(setRootItem);
		} catch (ClassCastException e) {
			// NOOP. A failed cast is not a sign of a problem, it just means that the spec had no child set.
		}

		try {
			final NamedSpecMap<?, ? extends Spec> specMap = HasChildMap.class.cast(rootSpec).getChildMap();
			final MapTreeItem mapRootItem = new MapTreeItem("Specification Map: " + specMap.getName(), specMap);
			mapRootItem.setRemove(() -> {
				specMap.clear();
				rootItem.getChildren().remove(mapRootItem);
				specificationTree.refresh();
			});
			specMap.forEach((key, spec) -> mapRootItem.getChildren().add(treeItemFromSpec(spec, key.toString(), mapRootItem, () -> specMap.remove(key))));
			rootItem.getChildren().add(mapRootItem);
		} catch (ClassCastException e) {
			// NOOP. A failed cast is not a sign of a problem, it just means that the spec had no child map.
			// This is again a situation where a non-optimal architecture was chosen with quirks such as this for the sake of
			// saving time.
		}

		return rootItem;
	}

	/**
	 * @return the window in which this controller lives.
	 */
	private Window getWindow() {
		return this.root
				.getScene()
				.getWindow();
	}

	/**
	 * Provides the TreeItems in specificationTree a way to remove themselves both from their parent TreeItem in
	 * specificationTree as well as to remove the specification they represent from the ClassMapSuite.
	 */
	private interface Removable {
		void remove();
	}

	/**
	 * A TreeItem for representing a single specification.
	 */
	private static class SpecTreeItem extends TreeItem<String> implements Removable {
		@Getter
		private final Spec spec;
		@Setter
		private Runnable remove;

		public SpecTreeItem(
				@NonNull final String title,
				/*Nullable*/ final Spec spec
		) {
			super(title);
			this.spec = spec;
		}

		public void remove() {
			remove.run();
		}
	}

	/**
	 * A TreeItem for displaying a map of specifications.
	 */
	private static class MapTreeItem extends TreeItem<String> implements Removable {
		private final NamedSpecMap map;
		@Setter
		private Runnable remove;

		public MapTreeItem(
				@NonNull final String title,
				@NonNull final NamedSpecMap map
		) {
			super(title);
			this.map = map;
		}

		public void remove() {
			remove.run();
		}
	}

	/**
	 * A TreeItem for displaying a set of specifications.
	 */
	private static class SetTreeItem extends TreeItem<String> implements Removable {
		private final NamedSpecSet set;
		@Setter
		private Runnable remove;

		public SetTreeItem(
				@NonNull final String title,
				@NonNull final NamedSpecSet set
		) {
			super(title);
			this.set = set;
		}

		public void remove() {
			remove.run();
		}
	}
}
